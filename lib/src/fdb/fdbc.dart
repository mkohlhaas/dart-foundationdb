// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// FoundationDB bindings
class FDBC {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FDBC(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FDBC.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.Char> fdb_get_error(
    int code,
  ) {
    return _fdb_get_error(
      code,
    );
  }

  late final _fdb_get_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'fdb_get_error');
  late final _fdb_get_error =
      _fdb_get_errorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int fdb_error_predicate(
    int predicate_test,
    int code,
  ) {
    return _fdb_error_predicate(
      predicate_test,
      code,
    );
  }

  late final _fdb_error_predicatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'fdb_error_predicate');
  late final _fdb_error_predicate =
      _fdb_error_predicatePtr.asFunction<int Function(int, int)>();

  int fdb_network_set_option(
    int option,
    ffi.Pointer<ffi.Uint8> value,
    int value_length,
  ) {
    return _fdb_network_set_option(
      option,
      value,
      value_length,
    );
  }

  late final _fdb_network_set_optionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int32, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_network_set_option');
  late final _fdb_network_set_option = _fdb_network_set_optionPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Uint8>, int)>();

  int fdb_setup_network() {
    return _fdb_setup_network();
  }

  late final _fdb_setup_networkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('fdb_setup_network');
  late final _fdb_setup_network =
      _fdb_setup_networkPtr.asFunction<int Function()>();

  int fdb_run_network() {
    return _fdb_run_network();
  }

  late final _fdb_run_networkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('fdb_run_network');
  late final _fdb_run_network =
      _fdb_run_networkPtr.asFunction<int Function()>();

  int fdb_stop_network() {
    return _fdb_stop_network();
  }

  late final _fdb_stop_networkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('fdb_stop_network');
  late final _fdb_stop_network =
      _fdb_stop_networkPtr.asFunction<int Function()>();

  int fdb_add_network_thread_completion_hook(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        hook,
    ffi.Pointer<ffi.Void> hook_parameter,
  ) {
    return _fdb_add_network_thread_completion_hook(
      hook,
      hook_parameter,
    );
  }

  late final _fdb_add_network_thread_completion_hookPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<
                  ffi.Void>)>>('fdb_add_network_thread_completion_hook');
  late final _fdb_add_network_thread_completion_hook =
      _fdb_add_network_thread_completion_hookPtr.asFunction<
          int Function(
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Void>)>();

  void fdb_future_cancel(
    ffi.Pointer<FDB_future> f,
  ) {
    return _fdb_future_cancel(
      f,
    );
  }

  late final _fdb_future_cancelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FDB_future>)>>(
          'fdb_future_cancel');
  late final _fdb_future_cancel = _fdb_future_cancelPtr
      .asFunction<void Function(ffi.Pointer<FDB_future>)>();

  void fdb_future_release_memory(
    ffi.Pointer<FDB_future> f,
  ) {
    return _fdb_future_release_memory(
      f,
    );
  }

  late final _fdb_future_release_memoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FDB_future>)>>(
          'fdb_future_release_memory');
  late final _fdb_future_release_memory = _fdb_future_release_memoryPtr
      .asFunction<void Function(ffi.Pointer<FDB_future>)>();

  void fdb_future_destroy(
    ffi.Pointer<FDB_future> f,
  ) {
    return _fdb_future_destroy(
      f,
    );
  }

  late final _fdb_future_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FDB_future>)>>(
          'fdb_future_destroy');
  late final _fdb_future_destroy = _fdb_future_destroyPtr
      .asFunction<void Function(ffi.Pointer<FDB_future>)>();

  int fdb_future_block_until_ready(
    ffi.Pointer<FDB_future> f,
  ) {
    return _fdb_future_block_until_ready(
      f,
    );
  }

  late final _fdb_future_block_until_readyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FDB_future>)>>(
          'fdb_future_block_until_ready');
  late final _fdb_future_block_until_ready = _fdb_future_block_until_readyPtr
      .asFunction<int Function(ffi.Pointer<FDB_future>)>();

  int fdb_future_is_ready(
    ffi.Pointer<FDB_future> f,
  ) {
    return _fdb_future_is_ready(
      f,
    );
  }

  late final _fdb_future_is_readyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FDB_future>)>>(
          'fdb_future_is_ready');
  late final _fdb_future_is_ready = _fdb_future_is_readyPtr
      .asFunction<int Function(ffi.Pointer<FDB_future>)>();

  int fdb_future_set_callback(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<FDB_future>, ffi.Pointer<ffi.Void>)>>
        callback,
    ffi.Pointer<ffi.Void> callback_parameter,
  ) {
    return _fdb_future_set_callback(
      f,
      callback,
      callback_parameter,
    );
  }

  late final _fdb_future_set_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<FDB_future>, ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Void>)>>('fdb_future_set_callback');
  late final _fdb_future_set_callback = _fdb_future_set_callbackPtr.asFunction<
      int Function(
          ffi.Pointer<FDB_future>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<FDB_future>, ffi.Pointer<ffi.Void>)>>,
          ffi.Pointer<ffi.Void>)>();

  int fdb_future_get_error(
    ffi.Pointer<FDB_future> f,
  ) {
    return _fdb_future_get_error(
      f,
    );
  }

  late final _fdb_future_get_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FDB_future>)>>(
          'fdb_future_get_error');
  late final _fdb_future_get_error = _fdb_future_get_errorPtr
      .asFunction<int Function(ffi.Pointer<FDB_future>)>();

  int fdb_future_get_bool(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Int> out,
  ) {
    return _fdb_future_get_bool(
      f,
      out,
    );
  }

  late final _fdb_future_get_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Int>)>>('fdb_future_get_bool');
  late final _fdb_future_get_bool = _fdb_future_get_boolPtr.asFunction<
      int Function(ffi.Pointer<FDB_future>, ffi.Pointer<ffi.Int>)>();

  int fdb_future_get_int64(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Int64> out,
  ) {
    return _fdb_future_get_int64(
      f,
      out,
    );
  }

  late final _fdb_future_get_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Int64>)>>('fdb_future_get_int64');
  late final _fdb_future_get_int64 = _fdb_future_get_int64Ptr.asFunction<
      int Function(ffi.Pointer<FDB_future>, ffi.Pointer<ffi.Int64>)>();

  int fdb_future_get_uint64(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Uint64> out,
  ) {
    return _fdb_future_get_uint64(
      f,
      out,
    );
  }

  late final _fdb_future_get_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Uint64>)>>('fdb_future_get_uint64');
  late final _fdb_future_get_uint64 = _fdb_future_get_uint64Ptr.asFunction<
      int Function(ffi.Pointer<FDB_future>, ffi.Pointer<ffi.Uint64>)>();

  int fdb_future_get_double(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Double> out,
  ) {
    return _fdb_future_get_double(
      f,
      out,
    );
  }

  late final _fdb_future_get_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Double>)>>('fdb_future_get_double');
  late final _fdb_future_get_double = _fdb_future_get_doublePtr.asFunction<
      int Function(ffi.Pointer<FDB_future>, ffi.Pointer<ffi.Double>)>();

  int fdb_future_get_key(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> out_key,
    ffi.Pointer<ffi.Int> out_key_length,
  ) {
    return _fdb_future_get_key(
      f,
      out_key,
      out_key_length,
    );
  }

  late final _fdb_future_get_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>)>>('fdb_future_get_key');
  late final _fdb_future_get_key = _fdb_future_get_keyPtr.asFunction<
      int Function(ffi.Pointer<FDB_future>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>)>();

  int fdb_future_get_value(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Int> out_present,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> out_value,
    ffi.Pointer<ffi.Int> out_value_length,
  ) {
    return _fdb_future_get_value(
      f,
      out_present,
      out_value,
      out_value_length,
    );
  }

  late final _fdb_future_get_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>)>>('fdb_future_get_value');
  late final _fdb_future_get_value = _fdb_future_get_valuePtr.asFunction<
      int Function(ffi.Pointer<FDB_future>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.Int>)>();

  int fdb_future_get_keyvalue_array(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Pointer<keyvalue>> out_kv,
    ffi.Pointer<ffi.Int> out_count,
    ffi.Pointer<ffi.Int> out_more,
  ) {
    return _fdb_future_get_keyvalue_array(
      f,
      out_kv,
      out_count,
      out_more,
    );
  }

  late final _fdb_future_get_keyvalue_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<keyvalue>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('fdb_future_get_keyvalue_array');
  late final _fdb_future_get_keyvalue_array =
      _fdb_future_get_keyvalue_arrayPtr.asFunction<
          int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<keyvalue>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  int fdb_future_get_mappedkeyvalue_array(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Pointer<mappedkeyvalue>> out_kv,
    ffi.Pointer<ffi.Int> out_count,
    ffi.Pointer<ffi.Int> out_more,
  ) {
    return _fdb_future_get_mappedkeyvalue_array(
      f,
      out_kv,
      out_count,
      out_more,
    );
  }

  late final _fdb_future_get_mappedkeyvalue_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<mappedkeyvalue>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('fdb_future_get_mappedkeyvalue_array');
  late final _fdb_future_get_mappedkeyvalue_array =
      _fdb_future_get_mappedkeyvalue_arrayPtr.asFunction<
          int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<mappedkeyvalue>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  int fdb_future_get_key_array(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Pointer<key>> out_key_array,
    ffi.Pointer<ffi.Int> out_count,
  ) {
    return _fdb_future_get_key_array(
      f,
      out_key_array,
      out_count,
    );
  }

  late final _fdb_future_get_key_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<key>>,
              ffi.Pointer<ffi.Int>)>>('fdb_future_get_key_array');
  late final _fdb_future_get_key_array =
      _fdb_future_get_key_arrayPtr.asFunction<
          int Function(ffi.Pointer<FDB_future>, ffi.Pointer<ffi.Pointer<key>>,
              ffi.Pointer<ffi.Int>)>();

  int fdb_future_get_string_array(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> out_strings,
    ffi.Pointer<ffi.Int> out_count,
  ) {
    return _fdb_future_get_string_array(
      f,
      out_strings,
      out_count,
    );
  }

  late final _fdb_future_get_string_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>,
              ffi.Pointer<ffi.Int>)>>('fdb_future_get_string_array');
  late final _fdb_future_get_string_array =
      _fdb_future_get_string_arrayPtr.asFunction<
          int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>,
              ffi.Pointer<ffi.Int>)>();

  int fdb_future_get_keyrange_array(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Pointer<keyrange>> out_ranges,
    ffi.Pointer<ffi.Int> out_count,
  ) {
    return _fdb_future_get_keyrange_array(
      f,
      out_ranges,
      out_count,
    );
  }

  late final _fdb_future_get_keyrange_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<keyrange>>,
              ffi.Pointer<ffi.Int>)>>('fdb_future_get_keyrange_array');
  late final _fdb_future_get_keyrange_array =
      _fdb_future_get_keyrange_arrayPtr.asFunction<
          int Function(ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<keyrange>>, ffi.Pointer<ffi.Int>)>();

  int fdb_future_get_granule_summary_array(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Pointer<granulesummary>> out_summaries,
    ffi.Pointer<ffi.Int> out_count,
  ) {
    return _fdb_future_get_granule_summary_array(
      f,
      out_summaries,
      out_count,
    );
  }

  late final _fdb_future_get_granule_summary_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<granulesummary>>,
              ffi.Pointer<ffi.Int>)>>('fdb_future_get_granule_summary_array');
  late final _fdb_future_get_granule_summary_array =
      _fdb_future_get_granule_summary_arrayPtr.asFunction<
          int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<granulesummary>>,
              ffi.Pointer<ffi.Int>)>();

  /// all for using future result from read_blob_granules_description
  int fdb_future_readbg_get_descriptions(
    ffi.Pointer<FDB_future> f,
    ffi.Pointer<ffi.Pointer<bgfiledescription>> out,
    ffi.Pointer<ffi.Int> desc_count,
  ) {
    return _fdb_future_readbg_get_descriptions(
      f,
      out,
      desc_count,
    );
  }

  late final _fdb_future_readbg_get_descriptionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<bgfiledescription>>,
              ffi.Pointer<ffi.Int>)>>('fdb_future_readbg_get_descriptions');
  late final _fdb_future_readbg_get_descriptions =
      _fdb_future_readbg_get_descriptionsPtr.asFunction<
          int Function(
              ffi.Pointer<FDB_future>,
              ffi.Pointer<ffi.Pointer<bgfiledescription>>,
              ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<FDB_result> fdb_readbg_parse_snapshot_file(
    ffi.Pointer<ffi.Uint8> file_data,
    int file_len,
    ffi.Pointer<bgtenantprefix> tenant_prefix,
    ffi.Pointer<bgencryptionctx> encryption_ctx,
  ) {
    return _fdb_readbg_parse_snapshot_file(
      file_data,
      file_len,
      tenant_prefix,
      encryption_ctx,
    );
  }

  late final _fdb_readbg_parse_snapshot_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_result> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<bgtenantprefix>,
              ffi.Pointer<bgencryptionctx>)>>('fdb_readbg_parse_snapshot_file');
  late final _fdb_readbg_parse_snapshot_file =
      _fdb_readbg_parse_snapshot_filePtr.asFunction<
          ffi.Pointer<FDB_result> Function(ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<bgtenantprefix>, ffi.Pointer<bgencryptionctx>)>();

  ffi.Pointer<FDB_result> fdb_readbg_parse_delta_file(
    ffi.Pointer<ffi.Uint8> file_data,
    int file_len,
    ffi.Pointer<bgtenantprefix> tenant_prefix,
    ffi.Pointer<bgencryptionctx> encryption_ctx,
  ) {
    return _fdb_readbg_parse_delta_file(
      file_data,
      file_len,
      tenant_prefix,
      encryption_ctx,
    );
  }

  late final _fdb_readbg_parse_delta_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_result> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<bgtenantprefix>,
              ffi.Pointer<bgencryptionctx>)>>('fdb_readbg_parse_delta_file');
  late final _fdb_readbg_parse_delta_file =
      _fdb_readbg_parse_delta_filePtr.asFunction<
          ffi.Pointer<FDB_result> Function(ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<bgtenantprefix>, ffi.Pointer<bgencryptionctx>)>();

  /// FDBResult is a synchronous computation result, as opposed to a future that is asynchronous.
  void fdb_result_destroy(
    ffi.Pointer<FDB_result> r,
  ) {
    return _fdb_result_destroy(
      r,
    );
  }

  late final _fdb_result_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FDB_result>)>>(
          'fdb_result_destroy');
  late final _fdb_result_destroy = _fdb_result_destroyPtr
      .asFunction<void Function(ffi.Pointer<FDB_result>)>();

  int fdb_result_get_keyvalue_array(
    ffi.Pointer<FDB_result> r,
    ffi.Pointer<ffi.Pointer<keyvalue>> out_kv,
    ffi.Pointer<ffi.Int> out_count,
    ffi.Pointer<ffi.Int> out_more,
  ) {
    return _fdb_result_get_keyvalue_array(
      r,
      out_kv,
      out_count,
      out_more,
    );
  }

  late final _fdb_result_get_keyvalue_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_result>,
              ffi.Pointer<ffi.Pointer<keyvalue>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('fdb_result_get_keyvalue_array');
  late final _fdb_result_get_keyvalue_array =
      _fdb_result_get_keyvalue_arrayPtr.asFunction<
          int Function(
              ffi.Pointer<FDB_result>,
              ffi.Pointer<ffi.Pointer<keyvalue>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  int fdb_result_get_bg_mutations_array(
    ffi.Pointer<FDB_result> r,
    ffi.Pointer<ffi.Pointer<bgmutation>> out_mutations,
    ffi.Pointer<ffi.Int> out_count,
  ) {
    return _fdb_result_get_bg_mutations_array(
      r,
      out_mutations,
      out_count,
    );
  }

  late final _fdb_result_get_bg_mutations_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_result>,
              ffi.Pointer<ffi.Pointer<bgmutation>>,
              ffi.Pointer<ffi.Int>)>>('fdb_result_get_bg_mutations_array');
  late final _fdb_result_get_bg_mutations_array =
      _fdb_result_get_bg_mutations_arrayPtr.asFunction<
          int Function(ffi.Pointer<FDB_result>,
              ffi.Pointer<ffi.Pointer<bgmutation>>, ffi.Pointer<ffi.Int>)>();

  /// TODO: add other return types as we need them
  int fdb_create_database(
    ffi.Pointer<ffi.Char> cluster_file_path,
    ffi.Pointer<ffi.Pointer<FDB_database>> out_database,
  ) {
    return _fdb_create_database(
      cluster_file_path,
      out_database,
    );
  }

  late final _fdb_create_databasePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<FDB_database>>)>>('fdb_create_database');
  late final _fdb_create_database = _fdb_create_databasePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<FDB_database>>)>();

  int fdb_create_database_from_connection_string(
    ffi.Pointer<ffi.Char> connection_string,
    ffi.Pointer<ffi.Pointer<FDB_database>> out_database,
  ) {
    return _fdb_create_database_from_connection_string(
      connection_string,
      out_database,
    );
  }

  late final _fdb_create_database_from_connection_stringPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<FDB_database>>)>>(
      'fdb_create_database_from_connection_string');
  late final _fdb_create_database_from_connection_string =
      _fdb_create_database_from_connection_stringPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<FDB_database>>)>();

  void fdb_database_destroy(
    ffi.Pointer<FDB_database> d,
  ) {
    return _fdb_database_destroy(
      d,
    );
  }

  late final _fdb_database_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FDB_database>)>>(
          'fdb_database_destroy');
  late final _fdb_database_destroy = _fdb_database_destroyPtr
      .asFunction<void Function(ffi.Pointer<FDB_database>)>();

  int fdb_database_set_option(
    ffi.Pointer<FDB_database> d,
    int option,
    ffi.Pointer<ffi.Uint8> value,
    int value_length,
  ) {
    return _fdb_database_set_option(
      d,
      option,
      value,
      value_length,
    );
  }

  late final _fdb_database_set_optionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FDB_database>, ffi.Int32,
              ffi.Pointer<ffi.Uint8>, ffi.Int)>>('fdb_database_set_option');
  late final _fdb_database_set_option = _fdb_database_set_optionPtr.asFunction<
      int Function(
          ffi.Pointer<FDB_database>, int, ffi.Pointer<ffi.Uint8>, int)>();

  int fdb_database_open_tenant(
    ffi.Pointer<FDB_database> d,
    ffi.Pointer<ffi.Uint8> tenant_name,
    int tenant_name_length,
    ffi.Pointer<ffi.Pointer<FDB_tenant>> out_tenant,
  ) {
    return _fdb_database_open_tenant(
      d,
      tenant_name,
      tenant_name_length,
      out_tenant,
    );
  }

  late final _fdb_database_open_tenantPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<FDB_database>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.Int,
                  ffi.Pointer<ffi.Pointer<FDB_tenant>>)>>(
      'fdb_database_open_tenant');
  late final _fdb_database_open_tenant =
      _fdb_database_open_tenantPtr.asFunction<
          int Function(ffi.Pointer<FDB_database>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Pointer<FDB_tenant>>)>();

  int fdb_database_create_transaction(
    ffi.Pointer<FDB_database> d,
    ffi.Pointer<ffi.Pointer<FDB_transaction>> out_transaction,
  ) {
    return _fdb_database_create_transaction(
      d,
      out_transaction,
    );
  }

  late final _fdb_database_create_transactionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<FDB_database>,
                  ffi.Pointer<ffi.Pointer<FDB_transaction>>)>>(
      'fdb_database_create_transaction');
  late final _fdb_database_create_transaction =
      _fdb_database_create_transactionPtr.asFunction<
          int Function(ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Pointer<FDB_transaction>>)>();

  ffi.Pointer<FDB_future> fdb_database_reboot_worker(
    ffi.Pointer<FDB_database> db,
    ffi.Pointer<ffi.Uint8> address,
    int address_length,
    int check,
    int duration,
  ) {
    return _fdb_database_reboot_worker(
      db,
      address,
      address_length,
      check,
      duration,
    );
  }

  late final _fdb_database_reboot_workerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('fdb_database_reboot_worker');
  late final _fdb_database_reboot_worker =
      _fdb_database_reboot_workerPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>, int, int, int)>();

  ffi.Pointer<FDB_future> fdb_database_force_recovery_with_data_loss(
    ffi.Pointer<FDB_database> db,
    ffi.Pointer<ffi.Uint8> dcid,
    int dcid_length,
  ) {
    return _fdb_database_force_recovery_with_data_loss(
      db,
      dcid,
      dcid_length,
    );
  }

  late final _fdb_database_force_recovery_with_data_lossPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_database_force_recovery_with_data_loss');
  late final _fdb_database_force_recovery_with_data_loss =
      _fdb_database_force_recovery_with_data_lossPtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_database_create_snapshot(
    ffi.Pointer<FDB_database> db,
    ffi.Pointer<ffi.Uint8> uid,
    int uid_length,
    ffi.Pointer<ffi.Uint8> snap_command,
    int snap_command_length,
  ) {
    return _fdb_database_create_snapshot(
      db,
      uid,
      uid_length,
      snap_command,
      snap_command_length,
    );
  }

  late final _fdb_database_create_snapshotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_database_create_snapshot');
  late final _fdb_database_create_snapshot =
      _fdb_database_create_snapshotPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  double fdb_database_get_main_thread_busyness(
    ffi.Pointer<FDB_database> db,
  ) {
    return _fdb_database_get_main_thread_busyness(
      db,
    );
  }

  late final _fdb_database_get_main_thread_busynessPtr = _lookup<
          ffi.NativeFunction<ffi.Double Function(ffi.Pointer<FDB_database>)>>(
      'fdb_database_get_main_thread_busyness');
  late final _fdb_database_get_main_thread_busyness =
      _fdb_database_get_main_thread_busynessPtr
          .asFunction<double Function(ffi.Pointer<FDB_database>)>();

  ffi.Pointer<FDB_future> fdb_database_get_server_protocol(
    ffi.Pointer<FDB_database> db,
    int expected_version,
  ) {
    return _fdb_database_get_server_protocol(
      db,
      expected_version,
    );
  }

  late final _fdb_database_get_server_protocolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_database>,
              ffi.Uint64)>>('fdb_database_get_server_protocol');
  late final _fdb_database_get_server_protocol =
      _fdb_database_get_server_protocolPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_database>, int)>();

  ffi.Pointer<FDB_future> fdb_database_purge_blob_granules(
    ffi.Pointer<FDB_database> db,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int purge_version,
    int force,
  ) {
    return _fdb_database_purge_blob_granules(
      db,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      purge_version,
      force,
    );
  }

  late final _fdb_database_purge_blob_granulesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int64,
              ffi.Int)>>('fdb_database_purge_blob_granules');
  late final _fdb_database_purge_blob_granules =
      _fdb_database_purge_blob_granulesPtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int)>();

  ffi.Pointer<FDB_future> fdb_database_wait_purge_granules_complete(
    ffi.Pointer<FDB_database> db,
    ffi.Pointer<ffi.Uint8> purge_key_name,
    int purge_key_name_length,
  ) {
    return _fdb_database_wait_purge_granules_complete(
      db,
      purge_key_name,
      purge_key_name_length,
    );
  }

  late final _fdb_database_wait_purge_granules_completePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_database_wait_purge_granules_complete');
  late final _fdb_database_wait_purge_granules_complete =
      _fdb_database_wait_purge_granules_completePtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_database_blobbify_range(
    ffi.Pointer<FDB_database> db,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
  ) {
    return _fdb_database_blobbify_range(
      db,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
    );
  }

  late final _fdb_database_blobbify_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_database_blobbify_range');
  late final _fdb_database_blobbify_range =
      _fdb_database_blobbify_rangePtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_database_blobbify_range_blocking(
    ffi.Pointer<FDB_database> db,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
  ) {
    return _fdb_database_blobbify_range_blocking(
      db,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
    );
  }

  late final _fdb_database_blobbify_range_blockingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_database_blobbify_range_blocking');
  late final _fdb_database_blobbify_range_blocking =
      _fdb_database_blobbify_range_blockingPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_database_unblobbify_range(
    ffi.Pointer<FDB_database> db,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
  ) {
    return _fdb_database_unblobbify_range(
      db,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
    );
  }

  late final _fdb_database_unblobbify_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_database_unblobbify_range');
  late final _fdb_database_unblobbify_range =
      _fdb_database_unblobbify_rangePtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_database_list_blobbified_ranges(
    ffi.Pointer<FDB_database> db,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int rangeLimit,
  ) {
    return _fdb_database_list_blobbified_ranges(
      db,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      rangeLimit,
    );
  }

  late final _fdb_database_list_blobbified_rangesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int)>>('fdb_database_list_blobbified_ranges');
  late final _fdb_database_list_blobbified_ranges =
      _fdb_database_list_blobbified_rangesPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  ffi.Pointer<FDB_future> fdb_database_verify_blob_range(
    ffi.Pointer<FDB_database> db,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int version,
  ) {
    return _fdb_database_verify_blob_range(
      db,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      version,
    );
  }

  late final _fdb_database_verify_blob_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int64)>>('fdb_database_verify_blob_range');
  late final _fdb_database_verify_blob_range =
      _fdb_database_verify_blob_rangePtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  ffi.Pointer<FDB_future> fdb_database_flush_blob_range(
    ffi.Pointer<FDB_database> db,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int compact,
    int version,
  ) {
    return _fdb_database_flush_blob_range(
      db,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      compact,
      version,
    );
  }

  late final _fdb_database_flush_blob_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int64)>>('fdb_database_flush_blob_range');
  late final _fdb_database_flush_blob_range =
      _fdb_database_flush_blob_rangePtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int)>();

  ffi.Pointer<FDB_future> fdb_database_get_client_status(
    ffi.Pointer<FDB_database> db,
  ) {
    return _fdb_database_get_client_status(
      db,
    );
  }

  late final _fdb_database_get_client_statusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_database>)>>('fdb_database_get_client_status');
  late final _fdb_database_get_client_status =
      _fdb_database_get_client_statusPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_database>)>();

  int fdb_tenant_create_transaction(
    ffi.Pointer<FDB_tenant> tenant,
    ffi.Pointer<ffi.Pointer<FDB_transaction>> out_transaction,
  ) {
    return _fdb_tenant_create_transaction(
      tenant,
      out_transaction,
    );
  }

  late final _fdb_tenant_create_transactionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<FDB_tenant>,
                  ffi.Pointer<ffi.Pointer<FDB_transaction>>)>>(
      'fdb_tenant_create_transaction');
  late final _fdb_tenant_create_transaction =
      _fdb_tenant_create_transactionPtr.asFunction<
          int Function(ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Pointer<FDB_transaction>>)>();

  ffi.Pointer<FDB_future> fdb_tenant_purge_blob_granules(
    ffi.Pointer<FDB_tenant> db,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int purge_version,
    int force,
  ) {
    return _fdb_tenant_purge_blob_granules(
      db,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      purge_version,
      force,
    );
  }

  late final _fdb_tenant_purge_blob_granulesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int64,
              ffi.Int)>>('fdb_tenant_purge_blob_granules');
  late final _fdb_tenant_purge_blob_granules =
      _fdb_tenant_purge_blob_granulesPtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int)>();

  ffi.Pointer<FDB_future> fdb_tenant_wait_purge_granules_complete(
    ffi.Pointer<FDB_tenant> db,
    ffi.Pointer<ffi.Uint8> purge_key_name,
    int purge_key_name_length,
  ) {
    return _fdb_tenant_wait_purge_granules_complete(
      db,
      purge_key_name,
      purge_key_name_length,
    );
  }

  late final _fdb_tenant_wait_purge_granules_completePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_tenant_wait_purge_granules_complete');
  late final _fdb_tenant_wait_purge_granules_complete =
      _fdb_tenant_wait_purge_granules_completePtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_tenant_blobbify_range(
    ffi.Pointer<FDB_tenant> tenant,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
  ) {
    return _fdb_tenant_blobbify_range(
      tenant,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
    );
  }

  late final _fdb_tenant_blobbify_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_tenant_blobbify_range');
  late final _fdb_tenant_blobbify_range =
      _fdb_tenant_blobbify_rangePtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_tenant_blobbify_range_blocking(
    ffi.Pointer<FDB_tenant> tenant,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
  ) {
    return _fdb_tenant_blobbify_range_blocking(
      tenant,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
    );
  }

  late final _fdb_tenant_blobbify_range_blockingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_tenant_blobbify_range_blocking');
  late final _fdb_tenant_blobbify_range_blocking =
      _fdb_tenant_blobbify_range_blockingPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_tenant_unblobbify_range(
    ffi.Pointer<FDB_tenant> tenant,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
  ) {
    return _fdb_tenant_unblobbify_range(
      tenant,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
    );
  }

  late final _fdb_tenant_unblobbify_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_tenant_unblobbify_range');
  late final _fdb_tenant_unblobbify_range =
      _fdb_tenant_unblobbify_rangePtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_tenant_list_blobbified_ranges(
    ffi.Pointer<FDB_tenant> tenant,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int rangeLimit,
  ) {
    return _fdb_tenant_list_blobbified_ranges(
      tenant,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      rangeLimit,
    );
  }

  late final _fdb_tenant_list_blobbified_rangesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int)>>('fdb_tenant_list_blobbified_ranges');
  late final _fdb_tenant_list_blobbified_ranges =
      _fdb_tenant_list_blobbified_rangesPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  ffi.Pointer<FDB_future> fdb_tenant_verify_blob_range(
    ffi.Pointer<FDB_tenant> tenant,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int version,
  ) {
    return _fdb_tenant_verify_blob_range(
      tenant,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      version,
    );
  }

  late final _fdb_tenant_verify_blob_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int64)>>('fdb_tenant_verify_blob_range');
  late final _fdb_tenant_verify_blob_range =
      _fdb_tenant_verify_blob_rangePtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  ffi.Pointer<FDB_future> fdb_tenant_flush_blob_range(
    ffi.Pointer<FDB_tenant> tenant,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int compact,
    int version,
  ) {
    return _fdb_tenant_flush_blob_range(
      tenant,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      compact,
      version,
    );
  }

  late final _fdb_tenant_flush_blob_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int64)>>('fdb_tenant_flush_blob_range');
  late final _fdb_tenant_flush_blob_range =
      _fdb_tenant_flush_blob_rangePtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int)>();

  ffi.Pointer<FDB_future> fdb_tenant_get_id(
    ffi.Pointer<FDB_tenant> tenant,
  ) {
    return _fdb_tenant_get_id(
      tenant,
    );
  }

  late final _fdb_tenant_get_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_tenant>)>>('fdb_tenant_get_id');
  late final _fdb_tenant_get_id = _fdb_tenant_get_idPtr
      .asFunction<ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_tenant>)>();

  void fdb_tenant_destroy(
    ffi.Pointer<FDB_tenant> tenant,
  ) {
    return _fdb_tenant_destroy(
      tenant,
    );
  }

  late final _fdb_tenant_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FDB_tenant>)>>(
          'fdb_tenant_destroy');
  late final _fdb_tenant_destroy = _fdb_tenant_destroyPtr
      .asFunction<void Function(ffi.Pointer<FDB_tenant>)>();

  void fdb_transaction_destroy(
    ffi.Pointer<FDB_transaction> tr,
  ) {
    return _fdb_transaction_destroy(
      tr,
    );
  }

  late final _fdb_transaction_destroyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FDB_transaction>)>>(
      'fdb_transaction_destroy');
  late final _fdb_transaction_destroy = _fdb_transaction_destroyPtr
      .asFunction<void Function(ffi.Pointer<FDB_transaction>)>();

  void fdb_transaction_cancel(
    ffi.Pointer<FDB_transaction> tr,
  ) {
    return _fdb_transaction_cancel(
      tr,
    );
  }

  late final _fdb_transaction_cancelPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FDB_transaction>)>>(
      'fdb_transaction_cancel');
  late final _fdb_transaction_cancel = _fdb_transaction_cancelPtr
      .asFunction<void Function(ffi.Pointer<FDB_transaction>)>();

  int fdb_transaction_set_option(
    ffi.Pointer<FDB_transaction> tr,
    int option,
    ffi.Pointer<ffi.Uint8> value,
    int value_length,
  ) {
    return _fdb_transaction_set_option(
      tr,
      option,
      value,
      value_length,
    );
  }

  late final _fdb_transaction_set_optionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FDB_transaction>, ffi.Int32,
              ffi.Pointer<ffi.Uint8>, ffi.Int)>>('fdb_transaction_set_option');
  late final _fdb_transaction_set_option =
      _fdb_transaction_set_optionPtr.asFunction<
          int Function(ffi.Pointer<FDB_transaction>, int,
              ffi.Pointer<ffi.Uint8>, int)>();

  void fdb_transaction_set_read_version(
    ffi.Pointer<FDB_transaction> tr,
    int version,
  ) {
    return _fdb_transaction_set_read_version(
      tr,
      version,
    );
  }

  late final _fdb_transaction_set_read_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FDB_transaction>,
              ffi.Int64)>>('fdb_transaction_set_read_version');
  late final _fdb_transaction_set_read_version =
      _fdb_transaction_set_read_versionPtr
          .asFunction<void Function(ffi.Pointer<FDB_transaction>, int)>();

  ffi.Pointer<FDB_future> fdb_transaction_get_read_version(
    ffi.Pointer<FDB_transaction> tr,
  ) {
    return _fdb_transaction_get_read_version(
      tr,
    );
  }

  late final _fdb_transaction_get_read_versionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>)>>(
      'fdb_transaction_get_read_version');
  late final _fdb_transaction_get_read_version =
      _fdb_transaction_get_read_versionPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>)>();

  ffi.Pointer<FDB_future> fdb_transaction_get(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> key_name,
    int key_name_length,
    int snapshot,
  ) {
    return _fdb_transaction_get(
      tr,
      key_name,
      key_name_length,
      snapshot,
    );
  }

  late final _fdb_transaction_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int)>>('fdb_transaction_get');
  late final _fdb_transaction_get = _fdb_transaction_getPtr.asFunction<
      ffi.Pointer<FDB_future> Function(
          ffi.Pointer<FDB_transaction>, ffi.Pointer<ffi.Uint8>, int, int)>();

  ffi.Pointer<FDB_future> fdb_transaction_get_key(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> key_name,
    int key_name_length,
    int or_equal,
    int offset,
    int snapshot,
  ) {
    return _fdb_transaction_get_key(
      tr,
      key_name,
      key_name_length,
      or_equal,
      offset,
      snapshot,
    );
  }

  late final _fdb_transaction_get_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('fdb_transaction_get_key');
  late final _fdb_transaction_get_key = _fdb_transaction_get_keyPtr.asFunction<
      ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>,
          ffi.Pointer<ffi.Uint8>, int, int, int, int)>();

  ffi.Pointer<FDB_future> fdb_transaction_get_addresses_for_key(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> key_name,
    int key_name_length,
  ) {
    return _fdb_transaction_get_addresses_for_key(
      tr,
      key_name,
      key_name_length,
    );
  }

  late final _fdb_transaction_get_addresses_for_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_transaction_get_addresses_for_key');
  late final _fdb_transaction_get_addresses_for_key =
      _fdb_transaction_get_addresses_for_keyPtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_transaction_get_range(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    int begin_or_equal,
    int begin_offset,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int end_or_equal,
    int end_offset,
    int limit,
    int target_bytes,
    int mode,
    int iteration,
    int snapshot,
    int reverse,
  ) {
    return _fdb_transaction_get_range(
      tr,
      begin_key_name,
      begin_key_name_length,
      begin_or_equal,
      begin_offset,
      end_key_name,
      end_key_name_length,
      end_or_equal,
      end_offset,
      limit,
      target_bytes,
      mode,
      iteration,
      snapshot,
      reverse,
    );
  }

  late final _fdb_transaction_get_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int32,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('fdb_transaction_get_range');
  late final _fdb_transaction_get_range =
      _fdb_transaction_get_rangePtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int,
              int,
              int,
              int,
              int,
              int,
              int)>();

  ffi.Pointer<FDB_future> fdb_transaction_get_mapped_range(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    int begin_or_equal,
    int begin_offset,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int end_or_equal,
    int end_offset,
    ffi.Pointer<ffi.Uint8> mapper_name,
    int mapper_name_length,
    int limit,
    int target_bytes,
    int mode,
    int iteration,
    int snapshot,
    int reverse,
  ) {
    return _fdb_transaction_get_mapped_range(
      tr,
      begin_key_name,
      begin_key_name_length,
      begin_or_equal,
      begin_offset,
      end_key_name,
      end_key_name_length,
      end_or_equal,
      end_offset,
      mapper_name,
      mapper_name_length,
      limit,
      target_bytes,
      mode,
      iteration,
      snapshot,
      reverse,
    );
  }

  late final _fdb_transaction_get_mapped_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int32,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('fdb_transaction_get_mapped_range');
  late final _fdb_transaction_get_mapped_range =
      _fdb_transaction_get_mapped_rangePtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int,
              int,
              int,
              int,
              int)>();

  void fdb_transaction_set(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> key_name,
    int key_name_length,
    ffi.Pointer<ffi.Uint8> value,
    int value_length,
  ) {
    return _fdb_transaction_set(
      tr,
      key_name,
      key_name_length,
      value,
      value_length,
    );
  }

  late final _fdb_transaction_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_transaction_set');
  late final _fdb_transaction_set = _fdb_transaction_setPtr.asFunction<
      void Function(ffi.Pointer<FDB_transaction>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  void fdb_transaction_atomic_op(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> key_name,
    int key_name_length,
    ffi.Pointer<ffi.Uint8> param,
    int param_length,
    int operation_type,
  ) {
    return _fdb_transaction_atomic_op(
      tr,
      key_name,
      key_name_length,
      param,
      param_length,
      operation_type,
    );
  }

  late final _fdb_transaction_atomic_opPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int32)>>('fdb_transaction_atomic_op');
  late final _fdb_transaction_atomic_op =
      _fdb_transaction_atomic_opPtr.asFunction<
          void Function(ffi.Pointer<FDB_transaction>, ffi.Pointer<ffi.Uint8>,
              int, ffi.Pointer<ffi.Uint8>, int, int)>();

  void fdb_transaction_clear(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> key_name,
    int key_name_length,
  ) {
    return _fdb_transaction_clear(
      tr,
      key_name,
      key_name_length,
    );
  }

  late final _fdb_transaction_clearPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>, ffi.Int)>>('fdb_transaction_clear');
  late final _fdb_transaction_clear = _fdb_transaction_clearPtr.asFunction<
      void Function(
          ffi.Pointer<FDB_transaction>, ffi.Pointer<ffi.Uint8>, int)>();

  void fdb_transaction_clear_range(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
  ) {
    return _fdb_transaction_clear_range(
      tr,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
    );
  }

  late final _fdb_transaction_clear_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_transaction_clear_range');
  late final _fdb_transaction_clear_range =
      _fdb_transaction_clear_rangePtr.asFunction<
          void Function(ffi.Pointer<FDB_transaction>, ffi.Pointer<ffi.Uint8>,
              int, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_transaction_watch(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> key_name,
    int key_name_length,
  ) {
    return _fdb_transaction_watch(
      tr,
      key_name,
      key_name_length,
    );
  }

  late final _fdb_transaction_watchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>, ffi.Int)>>('fdb_transaction_watch');
  late final _fdb_transaction_watch = _fdb_transaction_watchPtr.asFunction<
      ffi.Pointer<FDB_future> Function(
          ffi.Pointer<FDB_transaction>, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_transaction_commit(
    ffi.Pointer<FDB_transaction> tr,
  ) {
    return _fdb_transaction_commit(
      tr,
    );
  }

  late final _fdb_transaction_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>)>>('fdb_transaction_commit');
  late final _fdb_transaction_commit = _fdb_transaction_commitPtr.asFunction<
      ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>)>();

  int fdb_transaction_get_committed_version(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Int64> out_version,
  ) {
    return _fdb_transaction_get_committed_version(
      tr,
      out_version,
    );
  }

  late final _fdb_transaction_get_committed_versionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<FDB_transaction>, ffi.Pointer<ffi.Int64>)>>(
      'fdb_transaction_get_committed_version');
  late final _fdb_transaction_get_committed_version =
      _fdb_transaction_get_committed_versionPtr.asFunction<
          int Function(ffi.Pointer<FDB_transaction>, ffi.Pointer<ffi.Int64>)>();

  /// These functions intentionally return an FDBFuture instead of a numeric value
  /// directly, so that calling the API can see the effect of previous
  /// mutations on the transaction. Specifically, mutations are applied
  /// asynchronously by the main thread. In order to see them, this call has to
  /// be serviced by the main thread too.
  ffi.Pointer<FDB_future> fdb_transaction_get_tag_throttled_duration(
    ffi.Pointer<FDB_transaction> tr,
  ) {
    return _fdb_transaction_get_tag_throttled_duration(
      tr,
    );
  }

  late final _fdb_transaction_get_tag_throttled_durationPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>)>>(
      'fdb_transaction_get_tag_throttled_duration');
  late final _fdb_transaction_get_tag_throttled_duration =
      _fdb_transaction_get_tag_throttled_durationPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>)>();

  ffi.Pointer<FDB_future> fdb_transaction_get_total_cost(
    ffi.Pointer<FDB_transaction> tr,
  ) {
    return _fdb_transaction_get_total_cost(
      tr,
    );
  }

  late final _fdb_transaction_get_total_costPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>)>>('fdb_transaction_get_total_cost');
  late final _fdb_transaction_get_total_cost =
      _fdb_transaction_get_total_costPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>)>();

  ffi.Pointer<FDB_future> fdb_transaction_get_approximate_size(
    ffi.Pointer<FDB_transaction> tr,
  ) {
    return _fdb_transaction_get_approximate_size(
      tr,
    );
  }

  late final _fdb_transaction_get_approximate_sizePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>)>>(
      'fdb_transaction_get_approximate_size');
  late final _fdb_transaction_get_approximate_size =
      _fdb_transaction_get_approximate_sizePtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>)>();

  ffi.Pointer<FDB_future> fdb_transaction_get_versionstamp(
    ffi.Pointer<FDB_transaction> tr,
  ) {
    return _fdb_transaction_get_versionstamp(
      tr,
    );
  }

  late final _fdb_transaction_get_versionstampPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>)>>(
      'fdb_transaction_get_versionstamp');
  late final _fdb_transaction_get_versionstamp =
      _fdb_transaction_get_versionstampPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>)>();

  ffi.Pointer<FDB_future> fdb_transaction_on_error(
    ffi.Pointer<FDB_transaction> tr,
    int error,
  ) {
    return _fdb_transaction_on_error(
      tr,
      error,
    );
  }

  late final _fdb_transaction_on_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>,
              ffi.Int)>>('fdb_transaction_on_error');
  late final _fdb_transaction_on_error =
      _fdb_transaction_on_errorPtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>, int)>();

  void fdb_transaction_reset(
    ffi.Pointer<FDB_transaction> tr,
  ) {
    return _fdb_transaction_reset(
      tr,
    );
  }

  late final _fdb_transaction_resetPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FDB_transaction>)>>(
      'fdb_transaction_reset');
  late final _fdb_transaction_reset = _fdb_transaction_resetPtr
      .asFunction<void Function(ffi.Pointer<FDB_transaction>)>();

  int fdb_transaction_add_conflict_range(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int type,
  ) {
    return _fdb_transaction_add_conflict_range(
      tr,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      type,
    );
  }

  late final _fdb_transaction_add_conflict_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int32)>>('fdb_transaction_add_conflict_range');
  late final _fdb_transaction_add_conflict_range =
      _fdb_transaction_add_conflict_rangePtr.asFunction<
          int Function(ffi.Pointer<FDB_transaction>, ffi.Pointer<ffi.Uint8>,
              int, ffi.Pointer<ffi.Uint8>, int, int)>();

  ffi.Pointer<FDB_future> fdb_transaction_get_estimated_range_size_bytes(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
  ) {
    return _fdb_transaction_get_estimated_range_size_bytes(
      tr,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
    );
  }

  late final _fdb_transaction_get_estimated_range_size_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('fdb_transaction_get_estimated_range_size_bytes');
  late final _fdb_transaction_get_estimated_range_size_bytes =
      _fdb_transaction_get_estimated_range_size_bytesPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  ffi.Pointer<FDB_future> fdb_transaction_get_range_split_points(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int chunk_size,
  ) {
    return _fdb_transaction_get_range_split_points(
      tr,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      chunk_size,
    );
  }

  late final _fdb_transaction_get_range_split_pointsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int64)>>('fdb_transaction_get_range_split_points');
  late final _fdb_transaction_get_range_split_points =
      _fdb_transaction_get_range_split_pointsPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  ffi.Pointer<FDB_future> fdb_transaction_get_blob_granule_ranges(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int rangeLimit,
  ) {
    return _fdb_transaction_get_blob_granule_ranges(
      tr,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      rangeLimit,
    );
  }

  late final _fdb_transaction_get_blob_granule_rangesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int)>>('fdb_transaction_get_blob_granule_ranges');
  late final _fdb_transaction_get_blob_granule_ranges =
      _fdb_transaction_get_blob_granule_rangesPtr.asFunction<
          ffi.Pointer<FDB_future> Function(ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// LatestVersion (-2) for readVersion means get read version from transaction
  /// Separated out as optional because BG reads can support longer-lived reads than normal FDB transactions
  ffi.Pointer<FDB_result> fdb_transaction_read_blob_granules(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int beginVersion,
    int readVersion,
    readgranulecontext granuleContext,
  ) {
    return _fdb_transaction_read_blob_granules(
      tr,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      beginVersion,
      readVersion,
      granuleContext,
    );
  }

  late final _fdb_transaction_read_blob_granulesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_result> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int64,
              ffi.Int64,
              readgranulecontext)>>('fdb_transaction_read_blob_granules');
  late final _fdb_transaction_read_blob_granules =
      _fdb_transaction_read_blob_granulesPtr.asFunction<
          ffi.Pointer<FDB_result> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int,
              readgranulecontext)>();

  ffi.Pointer<FDB_future> fdb_transaction_summarize_blob_granules(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int summaryVersion,
    int rangeLimit,
  ) {
    return _fdb_transaction_summarize_blob_granules(
      tr,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      summaryVersion,
      rangeLimit,
    );
  }

  late final _fdb_transaction_summarize_blob_granulesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int64,
              ffi.Int)>>('fdb_transaction_summarize_blob_granules');
  late final _fdb_transaction_summarize_blob_granules =
      _fdb_transaction_summarize_blob_granulesPtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int)>();

  ffi.Pointer<FDB_future> fdb_transaction_read_blob_granules_description(
    ffi.Pointer<FDB_transaction> tr,
    ffi.Pointer<ffi.Uint8> begin_key_name,
    int begin_key_name_length,
    ffi.Pointer<ffi.Uint8> end_key_name,
    int end_key_name_length,
    int begin_version,
    int read_version,
    ffi.Pointer<ffi.Int64> read_version_out,
  ) {
    return _fdb_transaction_read_blob_granules_description(
      tr,
      begin_key_name,
      begin_key_name_length,
      end_key_name,
      end_key_name_length,
      begin_version,
      read_version,
      read_version_out,
    );
  }

  late final _fdb_transaction_read_blob_granules_descriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<FDB_future> Function(
                  ffi.Pointer<FDB_transaction>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.Int,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.Int,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Int64>)>>(
      'fdb_transaction_read_blob_granules_description');
  late final _fdb_transaction_read_blob_granules_description =
      _fdb_transaction_read_blob_granules_descriptionPtr.asFunction<
          ffi.Pointer<FDB_future> Function(
              ffi.Pointer<FDB_transaction>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<ffi.Uint8>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Int64>)>();

  int fdb_select_api_version_impl(
    int runtime_version,
    int header_version,
  ) {
    return _fdb_select_api_version_impl(
      runtime_version,
      header_version,
    );
  }

  late final _fdb_select_api_version_implPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'fdb_select_api_version_impl');
  late final _fdb_select_api_version_impl =
      _fdb_select_api_version_implPtr.asFunction<int Function(int, int)>();

  int fdb_get_max_api_version() {
    return _fdb_get_max_api_version();
  }

  late final _fdb_get_max_api_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'fdb_get_max_api_version');
  late final _fdb_get_max_api_version =
      _fdb_get_max_api_versionPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> fdb_get_client_version() {
    return _fdb_get_client_version();
  }

  late final _fdb_get_client_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'fdb_get_client_version');
  late final _fdb_get_client_version =
      _fdb_get_client_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();
}

/// FoundationDB C API
///
/// This source file is part of the FoundationDB open source project
///
/// Copyright 2013-2018 Apple Inc. and the FoundationDB project authors
///
/// Licensed under the Apache License, Version 2.0 (the 'License');
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
/// http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an 'AS IS' BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
/// Do not include this file directly.
abstract class FDBNetworkOption {
  /// Deprecated */
  /// /* Parameter: (String) IP:PORT
  static const int FDB_NET_OPTION_LOCAL_ADDRESS = 10;

  /// Deprecated */
  /// /* Parameter: (String) path to cluster file
  static const int FDB_NET_OPTION_CLUSTER_FILE = 20;

  /// Enables trace output to a file in a directory of the clients choosing */
  /// /* Parameter: (String) path to output directory (or NULL for current working directory)
  static const int FDB_NET_OPTION_TRACE_ENABLE = 30;

  /// Sets the maximum size in bytes of a single trace output file. This value should be in the range ``[0, INT64_MAX]``. If the value is set to 0, there is no limit on individual file size. The default is a maximum size of 10,485,760 bytes. */
  /// /* Parameter: (Int) max size of a single trace output file
  static const int FDB_NET_OPTION_TRACE_ROLL_SIZE = 31;

  /// Sets the maximum size of all the trace output files put together. This value should be in the range ``[0, INT64_MAX]``. If the value is set to 0, there is no limit on the total size of the files. The default is a maximum size of 104,857,600 bytes. If the default roll size is used, this means that a maximum of 10 trace files will be written at a time. */
  /// /* Parameter: (Int) max total size of trace files
  static const int FDB_NET_OPTION_TRACE_MAX_LOGS_SIZE = 32;

  /// Sets the 'LogGroup' attribute with the specified value for all events in the trace output files. The default log group is 'default'. */
  /// /* Parameter: (String) value of the LogGroup attribute
  static const int FDB_NET_OPTION_TRACE_LOG_GROUP = 33;

  /// Select the format of the log files. xml (the default) and json are supported. */
  /// /* Parameter: (String) Format of trace files
  static const int FDB_NET_OPTION_TRACE_FORMAT = 34;

  /// Select clock source for trace files. now (the default) or realtime are supported. */
  /// /* Parameter: (String) Trace clock source
  static const int FDB_NET_OPTION_TRACE_CLOCK_SOURCE = 35;

  /// Once provided, this string will be used to replace the port/PID in the log file names. */
  /// /* Parameter: (String) The identifier that will be part of all trace file names
  static const int FDB_NET_OPTION_TRACE_FILE_IDENTIFIER = 36;

  /// Use the same base trace file name for all client threads as it did before version 7.2. The current default behavior is to use distinct trace file names for client threads by including their version and thread index. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_TRACE_SHARE_AMONG_CLIENT_THREADS = 37;

  /// Initialize trace files on network setup, determine the local IP later. Otherwise tracing is initialized when opening the first database. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_TRACE_INITIALIZE_ON_SETUP = 38;

  /// Set file suffix for partially written log files. */
  /// /* Parameter: (String) Append this suffix to partially written log files. When a log file is complete, it is renamed to remove the suffix. No separator is added between the file and the suffix. If you want to add a file extension, you should include the separator - e.g. '.tmp' instead of 'tmp' to add the 'tmp' extension.
  static const int FDB_NET_OPTION_TRACE_PARTIAL_FILE_SUFFIX = 39;

  /// Set internal tuning or debugging knobs */
  /// /* Parameter: (String) knob_name=knob_value
  static const int FDB_NET_OPTION_KNOB = 40;

  /// Deprecated */
  /// /* Parameter: (String) file path or linker-resolved name
  static const int FDB_NET_OPTION_TLS_PLUGIN = 41;

  /// Set the certificate chain */
  /// /* Parameter: (Bytes) certificates
  static const int FDB_NET_OPTION_TLS_CERT_BYTES = 42;

  /// Set the file from which to load the certificate chain */
  /// /* Parameter: (String) file path
  static const int FDB_NET_OPTION_TLS_CERT_PATH = 43;

  /// Set the private key corresponding to your own certificate */
  /// /* Parameter: (Bytes) key
  static const int FDB_NET_OPTION_TLS_KEY_BYTES = 45;

  /// Set the file from which to load the private key corresponding to your own certificate */
  /// /* Parameter: (String) file path
  static const int FDB_NET_OPTION_TLS_KEY_PATH = 46;

  /// Set the peer certificate field verification criteria */
  /// /* Parameter: (Bytes) verification pattern
  static const int FDB_NET_OPTION_TLS_VERIFY_PEERS = 47;

  /// /
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_BUGGIFY_ENABLE = 48;

  /// /
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_BUGGIFY_DISABLE = 49;

  /// Set the probability of a BUGGIFY section being active for the current execution.  Only applies to code paths first traversed AFTER this option is changed. */
  /// /* Parameter: (Int) probability expressed as a percentage between 0 and 100
  static const int FDB_NET_OPTION_BUGGIFY_SECTION_ACTIVATED_PROBABILITY = 50;

  /// Set the probability of an active BUGGIFY section being fired */
  /// /* Parameter: (Int) probability expressed as a percentage between 0 and 100
  static const int FDB_NET_OPTION_BUGGIFY_SECTION_FIRED_PROBABILITY = 51;

  /// Set the ca bundle */
  /// /* Parameter: (Bytes) ca bundle
  static const int FDB_NET_OPTION_TLS_CA_BYTES = 52;

  /// Set the file from which to load the certificate authority bundle */
  /// /* Parameter: (String) file path
  static const int FDB_NET_OPTION_TLS_CA_PATH = 53;

  /// Set the passphrase for encrypted private key. Password should be set before setting the key for the password to be used. */
  /// /* Parameter: (String) key passphrase
  static const int FDB_NET_OPTION_TLS_PASSWORD = 54;

  /// Disables the multi-version client API and instead uses the local client directly. Must be set before setting up the network. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_DISABLE_MULTI_VERSION_CLIENT_API = 60;

  /// If set, callbacks from external client libraries can be called from threads created by the FoundationDB client library. Otherwise, callbacks will be called from either the thread used to add the callback or the network thread. Setting this option can improve performance when connected using an external client, but may not be safe to use in all environments. Must be set before setting up the network. WARNING: This feature is considered experimental at this time. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_CALLBACKS_ON_EXTERNAL_THREADS = 61;

  /// Adds an external client library for use by the multi-version client API. Must be set before setting up the network. */
  /// /* Parameter: (String) path to client library
  static const int FDB_NET_OPTION_EXTERNAL_CLIENT_LIBRARY = 62;

  /// Searches the specified path for dynamic libraries and adds them to the list of client libraries for use by the multi-version client API. Must be set before setting up the network. */
  /// /* Parameter: (String) path to directory containing client libraries
  static const int FDB_NET_OPTION_EXTERNAL_CLIENT_DIRECTORY = 63;

  /// Prevents connections through the local client, allowing only connections through externally loaded client libraries. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_DISABLE_LOCAL_CLIENT = 64;

  /// Spawns multiple worker threads for each version of the client that is loaded.  Setting this to a number greater than one implies disable_local_client. */
  /// /* Parameter: (Int) Number of client threads to be spawned.  Each cluster will be serviced by a single client thread.
  static const int FDB_NET_OPTION_CLIENT_THREADS_PER_VERSION = 65;

  /// Adds an external client library to be used with a future version protocol. This option can be used testing purposes only! */
  /// /* Parameter: (String) path to client library
  static const int FDB_NET_OPTION_FUTURE_VERSION_CLIENT_LIBRARY = 66;

  /// Retain temporary external client library copies that are created for enabling multi-threading. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_RETAIN_CLIENT_LIBRARY_COPIES = 67;

  /// Ignore the failure to initialize some of the external clients */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_IGNORE_EXTERNAL_CLIENT_FAILURES = 68;

  /// Fail with an error if there is no client matching the server version the client is connecting to */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_FAIL_INCOMPATIBLE_CLIENT = 69;

  /// Disables logging of client statistics, such as sampled transaction activity. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_DISABLE_CLIENT_STATISTICS_LOGGING = 70;

  /// Deprecated */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_ENABLE_SLOW_TASK_PROFILING = 71;

  /// Enables debugging feature to perform run loop profiling. Requires trace logging to be enabled. WARNING: this feature is not recommended for use in production. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_ENABLE_RUN_LOOP_PROFILING = 71;

  /// Prevents the multi-version client API from being disabled, even if no external clients are configured. This option is required to use GRV caching. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_DISABLE_CLIENT_BYPASS = 72;

  /// Enable client buggify - will make requests randomly fail (intended for client testing) */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_CLIENT_BUGGIFY_ENABLE = 80;

  /// Disable client buggify */
  /// /* Parameter: Option takes no parameter
  static const int FDB_NET_OPTION_CLIENT_BUGGIFY_DISABLE = 81;

  /// Set the probability of a CLIENT_BUGGIFY section being active for the current execution. */
  /// /* Parameter: (Int) probability expressed as a percentage between 0 and 100
  static const int FDB_NET_OPTION_CLIENT_BUGGIFY_SECTION_ACTIVATED_PROBABILITY =
      82;

  /// Set the probability of an active CLIENT_BUGGIFY section being fired. A section will only fire if it was activated */
  /// /* Parameter: (Int) probability expressed as a percentage between 0 and 100
  static const int FDB_NET_OPTION_CLIENT_BUGGIFY_SECTION_FIRED_PROBABILITY = 83;

  /// Set a tracer to run on the client. Should be set to the same value as the tracer set on the server. */
  /// /* Parameter: (String) Distributed tracer type. Choose from none, log_file, or network_lossy
  static const int FDB_NET_OPTION_DISTRIBUTED_CLIENT_TRACER = 90;

  /// Sets the directory for storing temporary files created by FDB client, such as temporary copies of client libraries. Defaults to /tmp */
  /// /* Parameter: (String) Client directory for temporary files.
  static const int FDB_NET_OPTION_CLIENT_TMP_DIR = 91;

  /// This option is set automatically to communicate the list of supported clients to the active client. */
  /// /* Parameter: (String) [release version],[source version],[protocol version];... This is a hidden parameter and should not be used directly by applications.
  static const int FDB_NET_OPTION_SUPPORTED_CLIENT_VERSIONS = 1000;

  /// This option is set automatically on all clients loaded externally using the multi-version API. */
  /// /* Parameter: Option takes no parameter This is a hidden parameter and should not be used directly by applications.
  static const int FDB_NET_OPTION_EXTERNAL_CLIENT = 1001;

  /// This option tells a child on a multiversion client what transport ID to use. */
  /// /* Parameter: (Int) Transport ID for the child connection This is a hidden parameter and should not be used directly by applications.
  static const int FDB_NET_OPTION_EXTERNAL_CLIENT_TRANSPORT_ID = 1002;
}

final class FDB_future extends ffi.Opaque {}

@ffi.Packed(4)
final class keyvalue extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> key;

  @ffi.Int()
  external int key_length;

  external ffi.Pointer<ffi.Uint8> value;

  @ffi.Int()
  external int value_length;
}

/// Memory layout of MappedKeyValueRef.
///
/// Total 112 bytes
/// - key (12 bytes)
/// :74:8F:8E:5F:AE:7F:00:00
/// :4A:00:00:00
/// - value (12 bytes)
/// :70:8F:8E:5F:AE:7F:00:00
/// :00:00:00:00
/// - begin selector (20 bytes)
/// :30:8F:8E:5F:AE:7F:00:00
/// :2D:00:00:00
/// :00:7F:00:00
/// :01:00:00:00
/// - end selector (20 bytes)
/// :EC:8E:8E:5F:AE:7F:00:00
/// :2D:00:00:00
/// :00:2B:3C:60
/// :01:00:00:00
/// - vector (16 bytes)
/// :74:94:8E:5F:AE:7F:00:00
/// :01:00:00:00
/// :01:00:00:00
/// - buffer (32 bytes)
/// :00:20:D1:61:00:00:00:00
/// :00:00:00:00:00:00:00:00
/// :00:00:00:00:00:00:00:00
/// :01:00:00:00:AE:7F:00:00
final class mappedkeyvalue extends ffi.Struct {
  external key key1;

  external key value;

  /// It's complicated to map a std::variant to C. For now we assume the underlying requests are always getRange and
  /// take the shortcut.
  external getrangereqandresult getRange;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.UnsignedChar> buffer;
}

@ffi.Packed(4)
final class key extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> key1;

  @ffi.Int()
  external int key_length;
}

/// Memory layout of GetRangeReqAndResultRef.
final class getrangereqandresult extends ffi.Struct {
  external keyselector begin;

  external keyselector end;

  external ffi.Pointer<keyvalue> data;

  @ffi.Int()
  external int m_size;

  @ffi.Int()
  external int m_capacity;
}

/// Memory layout of KeySelectorRef.
final class keyselector extends ffi.Struct {
  external key key1;

  /// orEqual and offset have not be tested in C binding. Just a placeholder.
  @ffi.Int()
  external int orEqual;

  @ffi.Int()
  external int offset;
}

@ffi.Packed(4)
final class keyrange extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> begin_key;

  @ffi.Int()
  external int begin_key_length;

  external ffi.Pointer<ffi.Uint8> end_key;

  @ffi.Int()
  external int end_key_length;
}

@ffi.Packed(4)
final class granulesummary extends ffi.Struct {
  external keyrange key_range;

  @ffi.Int64()
  external int snapshot_version;

  @ffi.Int64()
  external int snapshot_size;

  @ffi.Int64()
  external int delta_version;

  @ffi.Int64()
  external int delta_size;
}

@ffi.Packed(4)
final class bgfiledescription extends ffi.Struct {
  external keyrange key_range;

  @ffi.Int()
  external int snapshot_present;

  external bgfilepointer snapshot_file_pointer;

  @ffi.Int()
  external int delta_file_count;

  external ffi.Pointer<bgfilepointer> delta_files;

  @ffi.Int()
  external int memory_mutation_count;

  external ffi.Pointer<bgmutation> memory_mutations;

  external bgtenantprefix tenant_prefix;
}

@ffi.Packed(4)
final class bgfilepointer extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> filename_ptr;

  @ffi.Int()
  external int filename_length;

  @ffi.Int64()
  external int file_offset;

  @ffi.Int64()
  external int file_length;

  @ffi.Int64()
  external int full_file_length;

  @ffi.Int64()
  external int file_version;

  external bgencryptionctx encryption_ctx;
}

final class bgencryptionctx extends ffi.Struct {
  @ffi.Int()
  external int present;

  external bgencryptionkey textKey;

  @ffi.Uint32()
  external int textKCV;

  external bgencryptionkey headerKey;

  @ffi.Uint32()
  external int headerKCV;

  external key iv;
}

/// encryption structs correspond to similar ones in BlobGranuleCommon.h
@ffi.Packed(4)
final class bgencryptionkey extends ffi.Struct {
  @ffi.Int64()
  external int domain_id;

  @ffi.Uint64()
  external int base_key_id;

  @ffi.Uint32()
  external int base_kcv;

  @ffi.Uint64()
  external int random_salt;

  external key base_key;
}

@ffi.Packed(4)
final class bgmutation extends ffi.Struct {
  /// FDBBGMutationType
  @ffi.Uint8()
  external int type;

  @ffi.Int64()
  external int version;

  external ffi.Pointer<ffi.Uint8> param1_ptr;

  @ffi.Int()
  external int param1_length;

  external ffi.Pointer<ffi.Uint8> param2_ptr;

  @ffi.Int()
  external int param2_length;
}

final class bgtenantprefix extends ffi.Struct {
  @ffi.Int()
  external int present;

  external key prefix;
}

final class FDB_result extends ffi.Opaque {}

final class FDB_database extends ffi.Opaque {}

abstract class FDBDatabaseOption {
  /// Set the size of the client location cache. Raising this value can boost performance in very large databases where clients access data in a near-random pattern. Defaults to 100000. */
  /// /* Parameter: (Int) Max location cache entries
  static const int FDB_DB_OPTION_LOCATION_CACHE_SIZE = 10;

  /// Set the maximum number of watches allowed to be outstanding on a database connection. Increasing this number could result in increased resource usage. Reducing this number will not cancel any outstanding watches. Defaults to 10000 and cannot be larger than 1000000. */
  /// /* Parameter: (Int) Max outstanding watches
  static const int FDB_DB_OPTION_MAX_WATCHES = 20;

  /// Specify the machine ID that was passed to fdbserver processes running on the same machine as this client, for better location-aware load balancing. */
  /// /* Parameter: (String) Hexadecimal ID
  static const int FDB_DB_OPTION_MACHINE_ID = 21;

  /// Specify the datacenter ID that was passed to fdbserver processes running in the same datacenter as this client, for better location-aware load balancing. */
  /// /* Parameter: (String) Hexadecimal ID
  static const int FDB_DB_OPTION_DATACENTER_ID = 22;

  /// Snapshot read operations will see the results of writes done in the same transaction. This is the default behavior. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_DB_OPTION_SNAPSHOT_RYW_ENABLE = 26;

  /// Snapshot read operations will not see the results of writes done in the same transaction. This was the default behavior prior to API version 300. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_DB_OPTION_SNAPSHOT_RYW_DISABLE = 27;

  /// Sets the maximum escaped length of key and value fields to be logged to the trace file via the LOG_TRANSACTION option. This sets the ``transaction_logging_max_field_length`` option of each transaction created by this database. See the transaction option description for more information. */
  /// /* Parameter: (Int) Maximum length of escaped key and value fields.
  static const int FDB_DB_OPTION_TRANSACTION_LOGGING_MAX_FIELD_LENGTH = 405;

  /// Set a timeout in milliseconds which, when elapsed, will cause each transaction automatically to be cancelled. This sets the ``timeout`` option of each transaction created by this database. See the transaction option description for more information. Using this option requires that the API version is 610 or higher. */
  /// /* Parameter: (Int) value in milliseconds of timeout
  static const int FDB_DB_OPTION_TRANSACTION_TIMEOUT = 500;

  /// Set a maximum number of retries after which additional calls to ``onError`` will throw the most recently seen error code. This sets the ``retry_limit`` option of each transaction created by this database. See the transaction option description for more information. */
  /// /* Parameter: (Int) number of times to retry
  static const int FDB_DB_OPTION_TRANSACTION_RETRY_LIMIT = 501;

  /// Set the maximum amount of backoff delay incurred in the call to ``onError`` if the error is retryable. This sets the ``max_retry_delay`` option of each transaction created by this database. See the transaction option description for more information. */
  /// /* Parameter: (Int) value in milliseconds of maximum delay
  static const int FDB_DB_OPTION_TRANSACTION_MAX_RETRY_DELAY = 502;

  /// Set the maximum transaction size in bytes. This sets the ``size_limit`` option on each transaction created by this database. See the transaction option description for more information. */
  /// /* Parameter: (Int) value in bytes
  static const int FDB_DB_OPTION_TRANSACTION_SIZE_LIMIT = 503;

  /// The read version will be committed, and usually will be the latest committed, but might not be the latest committed in the event of a simultaneous fault and misbehaving clock. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_DB_OPTION_TRANSACTION_CAUSAL_READ_RISKY = 504;

  /// Deprecated. Addresses returned by get_addresses_for_key include the port when enabled. As of api version 630, this option is enabled by default and setting this has no effect. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_DB_OPTION_TRANSACTION_INCLUDE_PORT_IN_ADDRESS = 505;

  /// Set a random idempotency id for all transactions. See the transaction option description for more information. This feature is in development and not ready for general use. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_DB_OPTION_TRANSACTION_AUTOMATIC_IDEMPOTENCY = 506;

  /// Allows ``get`` operations to read from sections of keyspace that have become unreadable because of versionstamp operations. This sets the ``bypass_unreadable`` option of each transaction created by this database. See the transaction option description for more information. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_DB_OPTION_TRANSACTION_BYPASS_UNREADABLE = 700;

  /// By default, operations that are performed on a transaction while it is being committed will not only fail themselves, but they will attempt to fail other in-flight operations (such as the commit) as well. This behavior is intended to help developers discover situations where operations could be unintentionally executed after the transaction has been reset. Setting this option removes that protection, causing only the offending operation to fail. */
  /// /* Parameter: Option takes no parameter
  static const int
      FDB_DB_OPTION_TRANSACTION_USED_DURING_COMMIT_PROTECTION_DISABLE = 701;

  /// Enables conflicting key reporting on all transactions, allowing them to retrieve the keys that are conflicting with other transactions. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_DB_OPTION_TRANSACTION_REPORT_CONFLICTING_KEYS = 702;

  /// Use configuration database. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_DB_OPTION_USE_CONFIG_DATABASE = 800;

  /// Enables verification of causal read risky by checking whether clients are able to read stale data when they detect a recovery, and logging an error if so. */
  /// /* Parameter: (Int) integer between 0 and 100 expressing the probability a client will verify it can't read stale data
  static const int FDB_DB_OPTION_TEST_CAUSAL_READ_RISKY = 900;
}

final class FDB_tenant extends ffi.Opaque {}

final class FDB_transaction extends ffi.Opaque {}

abstract class FDBTransactionOption {
  /// The transaction, if not self-conflicting, may be committed a second time after commit succeeds, in the event of a fault */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_CAUSAL_WRITE_RISKY = 10;

  /// The read version will be committed, and usually will be the latest committed, but might not be the latest committed in the event of a simultaneous fault and misbehaving clock. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_CAUSAL_READ_RISKY = 20;

  /// /
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_CAUSAL_READ_DISABLE = 21;

  /// Addresses returned by get_addresses_for_key include the port when enabled. As of api version 630, this option is enabled by default and setting this has no effect. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_INCLUDE_PORT_IN_ADDRESS = 23;

  /// The next write performed on this transaction will not generate a write conflict range. As a result, other transactions which read the key(s) being modified by the next write will not conflict with this transaction. Care needs to be taken when using this option on a transaction that is shared between multiple threads. When setting this option, write conflict ranges will be disabled on the next write operation, regardless of what thread it is on. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_NEXT_WRITE_NO_WRITE_CONFLICT_RANGE = 30;

  /// Committing this transaction will bypass the normal load balancing across commit proxies and go directly to the specifically nominated 'first commit proxy'. */
  /// /* Parameter: Option takes no parameter This is a hidden parameter and should not be used directly by applications.
  static const int FDB_TR_OPTION_COMMIT_ON_FIRST_PROXY = 40;

  /// /
  /// /* Parameter: Option takes no parameter This is a hidden parameter and should not be used directly by applications.
  static const int FDB_TR_OPTION_CHECK_WRITES_ENABLE = 50;

  /// Reads performed by a transaction will not see any prior mutations that occured in that transaction, instead seeing the value which was in the database at the transaction's read version. This option may provide a small performance benefit for the client, but also disables a number of client-side optimizations which are beneficial for transactions which tend to read and write the same keys within a single transaction. It is an error to set this option after performing any reads or writes on the transaction. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_READ_YOUR_WRITES_DISABLE = 51;

  /// Deprecated */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_READ_AHEAD_DISABLE = 52;

  /// Storage server should cache disk blocks needed for subsequent read requests in this transaction.  This is the default behavior. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_READ_SERVER_SIDE_CACHE_ENABLE = 507;

  /// Storage server should not cache disk blocks needed for subsequent read requests in this transaction.  This can be used to avoid cache pollution for reads not expected to be repeated. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_READ_SERVER_SIDE_CACHE_DISABLE = 508;

  /// Use normal read priority for subsequent read requests in this transaction.  This is the default read priority. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_READ_PRIORITY_NORMAL = 509;

  /// Use low read priority for subsequent read requests in this transaction. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_READ_PRIORITY_LOW = 510;

  /// Use high read priority for subsequent read requests in this transaction. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_READ_PRIORITY_HIGH = 511;

  /// /
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_DURABILITY_DATACENTER = 110;

  /// /
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_DURABILITY_RISKY = 120;

  /// Deprecated */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_DURABILITY_DEV_NULL_IS_WEB_SCALE = 130;

  /// Specifies that this transaction should be treated as highest priority and that lower priority transactions should block behind this one. Use is discouraged outside of low-level tools */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_PRIORITY_SYSTEM_IMMEDIATE = 200;

  /// Specifies that this transaction should be treated as low priority and that default priority transactions will be processed first. Batch priority transactions will also be throttled at load levels smaller than for other types of transactions and may be fully cut off in the event of machine failures. Useful for doing batch work simultaneously with latency-sensitive work */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_PRIORITY_BATCH = 201;

  /// This is a write-only transaction which sets the initial configuration. This option is designed for use by database system tools only. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_INITIALIZE_NEW_DATABASE = 300;

  /// Allows this transaction to read and modify system keys (those that start with the byte 0xFF). Implies raw_access. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_ACCESS_SYSTEM_KEYS = 301;

  /// Allows this transaction to read system keys (those that start with the byte 0xFF). Implies raw_access. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_READ_SYSTEM_KEYS = 302;

  /// Allows this transaction to access the raw key-space when tenant mode is on. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_RAW_ACCESS = 303;

  /// Allows this transaction to bypass storage quota enforcement. Should only be used for transactions that directly or indirectly decrease the size of the tenant group's data. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_BYPASS_STORAGE_QUOTA = 304;

  /// /
  /// /* Parameter: Option takes no parameter This is a hidden parameter and should not be used directly by applications.
  static const int FDB_TR_OPTION_DEBUG_DUMP = 400;

  /// /
  /// /* Parameter: (String) Optional transaction name
  static const int FDB_TR_OPTION_DEBUG_RETRY_LOGGING = 401;

  /// Deprecated */
  /// /* Parameter: (String) String identifier to be used in the logs when tracing this transaction. The identifier must not exceed 100 characters.
  static const int FDB_TR_OPTION_TRANSACTION_LOGGING_ENABLE = 402;

  /// Sets a client provided identifier for the transaction that will be used in scenarios like tracing or profiling. Client trace logging or transaction profiling must be separately enabled. */
  /// /* Parameter: (String) String identifier to be used when tracing or profiling this transaction. The identifier must not exceed 100 characters.
  static const int FDB_TR_OPTION_DEBUG_TRANSACTION_IDENTIFIER = 403;

  /// Enables tracing for this transaction and logs results to the client trace logs. The DEBUG_TRANSACTION_IDENTIFIER option must be set before using this option, and client trace logging must be enabled to get log output. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_LOG_TRANSACTION = 404;

  /// Sets the maximum escaped length of key and value fields to be logged to the trace file via the LOG_TRANSACTION option, after which the field will be truncated. A negative value disables truncation. */
  /// /* Parameter: (Int) Maximum length of escaped key and value fields.
  static const int FDB_TR_OPTION_TRANSACTION_LOGGING_MAX_FIELD_LENGTH = 405;

  /// Sets an identifier for server tracing of this transaction. When committed, this identifier triggers logging when each part of the transaction authority encounters it, which is helpful in diagnosing slowness in misbehaving clusters. The identifier is randomly generated. When there is also a debug_transaction_identifier, both IDs are logged together. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_SERVER_REQUEST_TRACING = 406;

  /// Set a timeout in milliseconds which, when elapsed, will cause the transaction automatically to be cancelled. Valid parameter values are ``[0, INT_MAX]``. If set to 0, will disable all timeouts. All pending and any future uses of the transaction will throw an exception. The transaction can be used again after it is reset. Prior to API version 610, like all other transaction options, the timeout must be reset after a call to ``onError``. If the API version is 610 or greater, the timeout is not reset after an ``onError`` call. This allows the user to specify a longer timeout on specific transactions than the default timeout specified through the ``transaction_timeout`` database option without the shorter database timeout cancelling transactions that encounter a retryable error. Note that at all API versions, it is safe and legal to set the timeout each time the transaction begins, so most code written assuming the older behavior can be upgraded to the newer behavior without requiring any modification, and the caller is not required to implement special logic in retry loops to only conditionally set this option. */
  /// /* Parameter: (Int) value in milliseconds of timeout
  static const int FDB_TR_OPTION_TIMEOUT = 500;

  /// Set a maximum number of retries after which additional calls to ``onError`` will throw the most recently seen error code. Valid parameter values are ``[-1, INT_MAX]``. If set to -1, will disable the retry limit. Prior to API version 610, like all other transaction options, the retry limit must be reset after a call to ``onError``. If the API version is 610 or greater, the retry limit is not reset after an ``onError`` call. Note that at all API versions, it is safe and legal to set the retry limit each time the transaction begins, so most code written assuming the older behavior can be upgraded to the newer behavior without requiring any modification, and the caller is not required to implement special logic in retry loops to only conditionally set this option. */
  /// /* Parameter: (Int) number of times to retry
  static const int FDB_TR_OPTION_RETRY_LIMIT = 501;

  /// Set the maximum amount of backoff delay incurred in the call to ``onError`` if the error is retryable. Defaults to 1000 ms. Valid parameter values are ``[0, INT_MAX]``. If the maximum retry delay is less than the current retry delay of the transaction, then the current retry delay will be clamped to the maximum retry delay. Prior to API version 610, like all other transaction options, the maximum retry delay must be reset after a call to ``onError``. If the API version is 610 or greater, the retry limit is not reset after an ``onError`` call. Note that at all API versions, it is safe and legal to set the maximum retry delay each time the transaction begins, so most code written assuming the older behavior can be upgraded to the newer behavior without requiring any modification, and the caller is not required to implement special logic in retry loops to only conditionally set this option. */
  /// /* Parameter: (Int) value in milliseconds of maximum delay
  static const int FDB_TR_OPTION_MAX_RETRY_DELAY = 502;

  /// Set the transaction size limit in bytes. The size is calculated by combining the sizes of all keys and values written or mutated, all key ranges cleared, and all read and write conflict ranges. (In other words, it includes the total size of all data included in the request to the cluster to commit the transaction.) Large transactions can cause performance problems on FoundationDB clusters, so setting this limit to a smaller value than the default can help prevent the client from accidentally degrading the cluster's performance. This value must be at least 32 and cannot be set to higher than 10,000,000, the default transaction size limit. */
  /// /* Parameter: (Int) value in bytes
  static const int FDB_TR_OPTION_SIZE_LIMIT = 503;

  /// Associate this transaction with this ID for the purpose of checking whether or not this transaction has already committed. Must be at least 16 bytes and less than 256 bytes. This feature is in development and not ready for general use. Unless the automatic_idempotency option is set after this option, the client will not automatically attempt to remove this id from the cluster after a successful commit. */
  /// /* Parameter: (String) Unique ID This is a hidden parameter and should not be used directly by applications.
  static const int FDB_TR_OPTION_IDEMPOTENCY_ID = 504;

  /// Automatically assign a random 16 byte idempotency id for this transaction. Prevents commits from failing with ``commit_unknown_result``. WARNING: If you are also using the multiversion client or transaction timeouts, if either cluster_version_changed or transaction_timed_out was thrown during a commit, then that commit may have already succeeded or may succeed in the future. This feature is in development and not ready for general use. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_AUTOMATIC_IDEMPOTENCY = 505;

  /// Snapshot read operations will see the results of writes done in the same transaction. This is the default behavior. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_SNAPSHOT_RYW_ENABLE = 600;

  /// Snapshot read operations will not see the results of writes done in the same transaction. This was the default behavior prior to API version 300. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_SNAPSHOT_RYW_DISABLE = 601;

  /// The transaction can read and write to locked databases, and is responsible for checking that it took the lock. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_LOCK_AWARE = 700;

  /// By default, operations that are performed on a transaction while it is being committed will not only fail themselves, but they will attempt to fail other in-flight operations (such as the commit) as well. This behavior is intended to help developers discover situations where operations could be unintentionally executed after the transaction has been reset. Setting this option removes that protection, causing only the offending operation to fail. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_USED_DURING_COMMIT_PROTECTION_DISABLE = 701;

  /// The transaction can read from locked databases. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_READ_LOCK_AWARE = 702;

  /// No other transactions will be applied before this transaction within the same commit version. */
  /// /* Parameter: Option takes no parameter This is a hidden parameter and should not be used directly by applications.
  static const int FDB_TR_OPTION_FIRST_IN_BATCH = 710;

  /// This option should only be used by tools which change the database configuration. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_USE_PROVISIONAL_PROXIES = 711;

  /// The transaction can retrieve keys that are conflicting with other transactions. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_REPORT_CONFLICTING_KEYS = 712;

  /// By default, the special key space will only allow users to read from exactly one module (a subspace in the special key space). Use this option to allow reading from zero or more modules. Users who set this option should be prepared for new modules, which may have different behaviors than the modules they're currently reading. For example, a new module might block or return an error. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_SPECIAL_KEY_SPACE_RELAXED = 713;

  /// By default, users are not allowed to write to special keys. Enable this option will implicitly enable all options required to achieve the configuration change. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_SPECIAL_KEY_SPACE_ENABLE_WRITES = 714;

  /// Adds a tag to the transaction that can be used to apply manual targeted throttling. At most 5 tags can be set on a transaction. */
  /// /* Parameter: (String) String identifier used to associated this transaction with a throttling group. Must not exceed 16 characters.
  static const int FDB_TR_OPTION_TAG = 800;

  /// Adds a tag to the transaction that can be used to apply manual or automatic targeted throttling. At most 5 tags can be set on a transaction. */
  /// /* Parameter: (String) String identifier used to associated this transaction with a throttling group. Must not exceed 16 characters.
  static const int FDB_TR_OPTION_AUTO_THROTTLE_TAG = 801;

  /// Adds a parent to the Span of this transaction. Used for transaction tracing. A span can be identified with any 16 bytes */
  /// /* Parameter: (Bytes) A byte string of length 16 used to associate the span of this transaction with a parent
  static const int FDB_TR_OPTION_SPAN_PARENT = 900;

  /// Asks storage servers for how many bytes a clear key range contains. Otherwise uses the location cache to roughly estimate this. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_EXPENSIVE_CLEAR_COST_ESTIMATION_ENABLE = 1000;

  /// Allows ``get`` operations to read from sections of keyspace that have become unreadable because of versionstamp operations. These reads will view versionstamp operations as if they were set operations that did not fill in the versionstamp. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_BYPASS_UNREADABLE = 1100;

  /// Allows this transaction to use cached GRV from the database context. Defaults to off. Upon first usage, starts a background updater to periodically update the cache to avoid stale read versions. The disable_client_bypass option must also be set. */
  /// /* Parameter: Option takes no parameter
  static const int FDB_TR_OPTION_USE_GRV_CACHE = 1101;

  /// Specifically instruct this transaction to NOT use cached GRV. Primarily used for the read version cache's background updater to avoid attempting to read a cached entry in specific situations. */
  /// /* Parameter: Option takes no parameter This is a hidden parameter and should not be used directly by applications.
  static const int FDB_TR_OPTION_SKIP_GRV_CACHE = 1102;

  /// Attach given authorization token to the transaction such that subsequent tenant-aware requests are authorized */
  /// /* Parameter: (String) A JSON Web Token authorized to access data belonging to one or more tenants, indicated by 'tenants' claim of the token's payload.
  static const int FDB_TR_OPTION_AUTHORIZATION_TOKEN = 2000;
}

abstract class FDBStreamingMode {
  /// Client intends to consume the entire range and would like it all transferred as early as possible.
  static const int FDB_STREAMING_MODE_WANT_ALL = -2;

  /// The default. The client doesn't know how much of the range it is likely to used and wants different performance concerns to be balanced. Only a small portion of data is transferred to the client initially (in order to minimize costs if the client doesn't read the entire range), and as the caller iterates over more items in the range larger batches will be transferred in order to minimize latency. After enough iterations, the iterator mode will eventually reach the same byte limit as ``WANT_ALL``
  static const int FDB_STREAMING_MODE_ITERATOR = -1;

  /// Infrequently used. The client has passed a specific row limit and wants that many rows delivered in a single batch. Because of iterator operation in client drivers make request batches transparent to the user, consider ``WANT_ALL`` StreamingMode instead. A row limit must be specified if this mode is used.
  static const int FDB_STREAMING_MODE_EXACT = 0;

  /// Infrequently used. Transfer data in batches small enough to not be much more expensive than reading individual rows, to minimize cost if iteration stops early.
  static const int FDB_STREAMING_MODE_SMALL = 1;

  /// Infrequently used. Transfer data in batches sized in between small and large.
  static const int FDB_STREAMING_MODE_MEDIUM = 2;

  /// Infrequently used. Transfer data in batches large enough to be, in a high-concurrency environment, nearly as efficient as possible. If the client stops iteration early, some disk and network bandwidth may be wasted. The batch size may still be too small to allow a single client to get high throughput from the database, so if that is what you need consider the SERIAL StreamingMode.
  static const int FDB_STREAMING_MODE_LARGE = 3;

  /// Transfer data in batches large enough that an individual client can get reasonable read bandwidth from the database. If the client stops iteration early, considerable disk and network bandwidth may be wasted.
  static const int FDB_STREAMING_MODE_SERIAL = 4;
}

abstract class FDBMutationType {
  /// Performs an addition of little-endian integers. If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``. The integers to be added must be stored in a little-endian representation.  They can be signed in two's complement representation or unsigned. You can add to an integer at a known offset in the value by prepending the appropriate number of zero bytes to ``param`` and padding with zero bytes to match the length of the value. However, this offset technique requires that you know the addition will not cause the integer field within the value to overflow.
  static const int FDB_MUTATION_TYPE_ADD = 2;

  /// Deprecated
  static const int FDB_MUTATION_TYPE_AND = 6;

  /// Performs a bitwise ``and`` operation.  If the existing value in the database is not present, then ``param`` is stored in the database. If the existing value in the database is shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``.
  static const int FDB_MUTATION_TYPE_BIT_AND = 6;

  /// Deprecated
  static const int FDB_MUTATION_TYPE_OR = 7;

  /// Performs a bitwise ``or`` operation.  If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``.
  static const int FDB_MUTATION_TYPE_BIT_OR = 7;

  /// Deprecated
  static const int FDB_MUTATION_TYPE_XOR = 8;

  /// Performs a bitwise ``xor`` operation.  If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``.
  static const int FDB_MUTATION_TYPE_BIT_XOR = 8;

  /// Appends ``param`` to the end of the existing value already in the database at the given key (or creates the key and sets the value to ``param`` if the key is empty). This will only append the value if the final concatenated value size is less than or equal to the maximum value size (i.e., if it fits). WARNING: No error is surfaced back to the user if the final value is too large because the mutation will not be applied until after the transaction has been committed. Therefore, it is only safe to use this mutation type if one can guarantee that one will keep the total value size under the maximum size.
  static const int FDB_MUTATION_TYPE_APPEND_IF_FITS = 9;

  /// Performs a little-endian comparison of byte strings. If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``. The larger of the two values is then stored in the database.
  static const int FDB_MUTATION_TYPE_MAX = 12;

  /// Performs a little-endian comparison of byte strings. If the existing value in the database is not present, then ``param`` is stored in the database. If the existing value in the database is shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``. The smaller of the two values is then stored in the database.
  static const int FDB_MUTATION_TYPE_MIN = 13;

  /// Transforms ``key`` using a versionstamp for the transaction. Sets the transformed key in the database to ``param``. The key is transformed by removing the final four bytes from the key and reading those as a little-Endian 32-bit integer to get a position ``pos``. The 10 bytes of the key from ``pos`` to ``pos + 10`` are replaced with the versionstamp of the transaction used. The first byte of the key is position 0. A versionstamp is a 10 byte, unique, monotonically (but not sequentially) increasing value for each committed transaction. The first 8 bytes are the committed version of the database (serialized in big-Endian order). The last 2 bytes are monotonic in the serialization order for transactions. WARNING: At this time, versionstamps are compatible with the Tuple layer only in the Java, Python, and Go bindings. Also, note that prior to API version 520, the offset was computed from only the final two bytes rather than the final four bytes.
  static const int FDB_MUTATION_TYPE_SET_VERSIONSTAMPED_KEY = 14;

  /// Transforms ``param`` using a versionstamp for the transaction. Sets the ``key`` given to the transformed ``param``. The parameter is transformed by removing the final four bytes from ``param`` and reading those as a little-Endian 32-bit integer to get a position ``pos``. The 10 bytes of the parameter from ``pos`` to ``pos + 10`` are replaced with the versionstamp of the transaction used. The first byte of the parameter is position 0. A versionstamp is a 10 byte, unique, monotonically (but not sequentially) increasing value for each committed transaction. The first 8 bytes are the committed version of the database (serialized in big-Endian order). The last 2 bytes are monotonic in the serialization order for transactions. WARNING: At this time, versionstamps are compatible with the Tuple layer only in the Java, Python, and Go bindings. Also, note that prior to API version 520, the versionstamp was always placed at the beginning of the parameter rather than computing an offset.
  static const int FDB_MUTATION_TYPE_SET_VERSIONSTAMPED_VALUE = 15;

  /// Performs lexicographic comparison of byte strings. If the existing value in the database is not present, then ``param`` is stored. Otherwise the smaller of the two values is then stored in the database.
  static const int FDB_MUTATION_TYPE_BYTE_MIN = 16;

  /// Performs lexicographic comparison of byte strings. If the existing value in the database is not present, then ``param`` is stored. Otherwise the larger of the two values is then stored in the database.
  static const int FDB_MUTATION_TYPE_BYTE_MAX = 17;

  /// Performs an atomic ``compare and clear`` operation. If the existing value in the database is equal to the given value, then given key is cleared.
  static const int FDB_MUTATION_TYPE_COMPARE_AND_CLEAR = 20;
}

abstract class FDBConflictRangeType {
  /// Used to add a read conflict range
  static const int FDB_CONFLICT_RANGE_TYPE_READ = 0;

  /// Used to add a write conflict range
  static const int FDB_CONFLICT_RANGE_TYPE_WRITE = 1;
}

final class readgranulecontext extends ffi.Struct {
  /// User context to pass along to functions
  external ffi.Pointer<ffi.Void> userContext;

  /// Returns a unique id for the load. Asynchronous to support queueing multiple in parallel.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int64 Function(
              ffi.Pointer<ffi.Char> filename,
              ffi.Int filenameLength,
              ffi.Int64 offset,
              ffi.Int64 length,
              ffi.Int64 fullFileLength,
              ffi.Pointer<ffi.Void> context)>> start_load_f;

  /// Returns data for the load. Pass the loadId returned by start_load_f
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Int64 loadId, ffi.Pointer<ffi.Void> context)>> get_load_f;

  /// Frees data from load. Pass the loadId returned by start_load_f
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int64 loadId, ffi.Pointer<ffi.Void> context)>> free_load_f;

  /// Set this to true for testing if you don't want to read the granule files,
  /// just do the request to the blob workers
  @ffi.Int()
  external int debugNoMaterialize;

  /// Number of granules to load in parallel
  @ffi.Int()
  external int granuleParallelism;
}
